<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Recursión Fix - Tidal Camera</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #1a1a1a; 
            color: #fff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
        }
        
        .controls button {
            margin: 5px;
            padding: 10px 15px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .controls button:hover {
            background: #0088ff;
        }
        
        .controls button.active {
            background: #00aa00;
        }
        
        .controls button.danger {
            background: #cc0000;
        }
        
        .status {
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            font-family: monospace;
        }
        
        .status.error {
            background: #330000;
            color: #ff6666;
        }
        
        .status.success {
            background: #003300;
            color: #66ff66;
        }
        
        .chart-container {
            height: 500px;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }
        
        .metrics {
            margin-top: 20px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .metric {
            text-align: center;
            padding: 10px;
            background: #444;
            border-radius: 4px;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00aa00;
        }
        
        .metric-label {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }
        
        .metric.error .metric-value {
            color: #ff6666;
        }
        
        .log {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #444;
        }
        
        .log-entry {
            margin-bottom: 2px;
            padding: 2px 4px;
        }
        
        .log-entry.error {
            background: #330000;
            color: #ff6666;
        }
        
        .log-entry.success {
            background: #003300;
            color: #66ff66;
        }
        
        .log-entry.warning {
            background: #333300;
            color: #ffff66;
        }
        
        .log-entry.info {
            color: #66ccff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧪 Test Recursión Fix - Sistema Tidal Camera</h1>
        
        <div class="controls">
            <button id="startTest">▶️ Iniciar Test de Stress</button>
            <button id="stopTest">⏹️ Detener Test</button>
            <button id="clearLog">🧹 Limpiar Log</button>
            <button id="testRecursion" class="danger">💥 Test Recursión Forzada</button>
        </div>
        
        <div id="status" class="status">
            🔄 Sistema inicializando...
        </div>
        
        <div class="chart-container">
            <canvas id="chart" width="800" height="400"></canvas>
        </div>
        
        <div class="metrics">
            <div class="metric">
                <div id="updateCount" class="metric-value">0</div>
                <div class="metric-label">Updates Procesados</div>
            </div>
            <div class="metric">
                <div id="errorCount" class="metric-value">0</div>
                <div class="metric-label">Errores Detectados</div>
            </div>
            <div class="metric">
                <div id="performance" class="metric-value">0ms</div>
                <div class="metric-label">Tiempo Promedio</div>
            </div>
            <div class="metric">
                <div id="memoryUsage" class="metric-value">0MB</div>
                <div class="metric-label">Memoria Usada</div>
            </div>
        </div>
        
        <div id="log" class="log"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    
    <script>
        // Estado del test
        let testRunning = false;
        let updateInterval;
        let updateCount = 0;
        let errorCount = 0;
        let performanceTimes = [];
        let chart;
        
        // Referencias DOM
        const startBtn = document.getElementById('startTest');
        const stopBtn = document.getElementById('stopTest');
        const clearBtn = document.getElementById('clearLog');
        const recursionBtn = document.getElementById('testRecursion');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        
        // Simulador del sistema de cámara tidal
        class MockTidalCamera {
            constructor() {
                this.state = {
                    mode: 'auto',
                    isLocked: false,
                    lastUserAction: null,
                    chartJsState: { min: 0, max: 100 },
                    tidalConfig: { factor: 0.618, histeresis: 5 }
                };
                this.inMutation = false;
                this.updateCallStack = [];
            }
            
            // Simular el método problemático que causaba recursión
            applyViewportToChart(viewport) {
                // Detectar recursión
                if (this.inMutation) {
                    this.logError('RECURSIÓN DETECTADA en applyViewportToChart');
                    throw new Error('Maximum call stack size exceeded');
                }
                
                this.inMutation = true;
                
                try {
                    // Simular aplicación de viewport
                    this.state.chartJsState = { ...viewport };
                    this.log(`Viewport aplicado: min=${viewport.min.toFixed(2)}, max=${viewport.max.toFixed(2)}`);
                } finally {
                    this.inMutation = false;
                }
            }
            
            updateWithCandle(candle) {
                const startTime = performance.now();
                
                try {
                    // Simular el procesamiento que podría causar recursión
                    const newViewport = this.computeTidalViewport(candle);
                    this.applyViewportToChart(newViewport);
                    
                    const endTime = performance.now();
                    const duration = endTime - startTime;
                    performanceTimes.push(duration);
                    
                    updateCount++;
                    this.updateMetrics();
                    
                    this.log(`Update procesado en ${duration.toFixed(2)}ms`, 'success');
                    
                } catch (error) {
                    errorCount++;
                    this.logError(`Error en update: ${error.message}`);
                    this.updateStatus('ERROR: ' + error.message, 'error');
                    throw error;
                }
            }
            
            computeTidalViewport(candle) {
                // Simular cálculo tidal con posibilidad de recursión
                const factor = this.state.tidalConfig.factor;
                
                return {
                    min: candle.x - (100 * (1 - factor)),
                    max: candle.x + (100 * factor)
                };
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${timestamp}] ${message}`;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;
            }
            
            logError(message) {
                this.log(message, 'error');
                console.error(message);
            }
            
            updateMetrics() {
                document.getElementById('updateCount').textContent = updateCount;
                document.getElementById('errorCount').textContent = errorCount;
                
                if (performanceTimes.length > 0) {
                    const avgTime = performanceTimes.reduce((a, b) => a + b, 0) / performanceTimes.length;
                    document.getElementById('performance').textContent = avgTime.toFixed(2) + 'ms';
                }
                
                // Memoria aproximada
                if (performance.memory) {
                    const memMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    document.getElementById('memoryUsage').textContent = memMB + 'MB';
                }
                
                // Color de error si hay errores
                const errorMetric = document.getElementById('errorCount').parentElement;
                if (errorCount > 0) {
                    errorMetric.classList.add('error');
                } else {
                    errorMetric.classList.remove('error');
                }
            }
            
            updateStatus(message, type = '') {
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
            }
        }
        
        // Inicializar sistema
        const tidalCamera = new MockTidalCamera();
        
        // Generar datos de prueba
        function generateTestCandle() {
            const now = Date.now();
            const price = 50000 + Math.random() * 1000;
            
            return {
                x: now,
                o: price - Math.random() * 100,
                h: price + Math.random() * 100,
                l: price - Math.random() * 100,
                c: price
            };
        }
        
        // Test de stress normal
        function startStressTest() {
            if (testRunning) return;
            
            testRunning = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            tidalCamera.updateStatus('🔥 Test de stress ejecutándose...', 'success');
            tidalCamera.log('Iniciando test de stress con 100 updates/segundo', 'info');
            
            updateInterval = setInterval(() => {
                try {
                    const candle = generateTestCandle();
                    tidalCamera.updateWithCandle(candle);
                    
                    if (updateCount % 100 === 0) {
                        tidalCamera.log(`Procesados ${updateCount} updates sin errores`, 'success');
                    }
                    
                } catch (error) {
                    tidalCamera.logError(`Test fallido: ${error.message}`);
                    stopStressTest();
                }
            }, 10); // 100 updates por segundo
        }
        
        function stopStressTest() {
            if (!testRunning) return;
            
            testRunning = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            
            const status = errorCount === 0 ? 'success' : 'error';
            const message = errorCount === 0 
                ? `✅ Test completado: ${updateCount} updates sin errores`
                : `❌ Test terminado: ${errorCount} errores de ${updateCount} updates`;
            
            tidalCamera.updateStatus(message, status);
            tidalCamera.log(`Test de stress finalizado: ${updateCount} updates, ${errorCount} errores`, status);
        }
        
        // Test de recursión forzada
        function testForcedRecursion() {
            tidalCamera.log('🧨 Iniciando test de recursión forzada...', 'warning');
            
            try {
                // Simular el bug que causaba recursión
                tidalCamera.inMutation = false; // Reset del guard
                
                // Crear situación recursiva artificial
                const oldApply = tidalCamera.applyViewportToChart;
                tidalCamera.applyViewportToChart = function(viewport) {
                    // Simular llamada recursiva
                    if (!this.inMutation) {
                        this.inMutation = true;
                        this.applyViewportToChart(viewport); // Recursión!
                    }
                };
                
                const candle = generateTestCandle();
                tidalCamera.updateWithCandle(candle);
                
                tidalCamera.log('❌ Test de recursión debería haber fallado', 'error');
                
            } catch (error) {
                tidalCamera.log(`✅ Recursión detectada correctamente: ${error.message}`, 'success');
            }
        }
        
        function clearLog() {
            logDiv.innerHTML = '';
            updateCount = 0;
            errorCount = 0;
            performanceTimes = [];
            tidalCamera.updateMetrics();
            tidalCamera.updateStatus('🔄 Log limpiado, métricas reseteadas');
        }
        
        // Event listeners
        startBtn.addEventListener('click', startStressTest);
        stopBtn.addEventListener('click', stopStressTest);
        clearBtn.addEventListener('click', clearLog);
        recursionBtn.addEventListener('click', testForcedRecursion);
        
        // Inicialización
        tidalCamera.updateStatus('✅ Sistema listo para pruebas', 'success');
        tidalCamera.log('Mock Tidal Camera System inicializado', 'info');
        tidalCamera.log('Presiona "Iniciar Test" para comenzar stress test', 'info');
        
        // Monitoreo de memoria cada 5 segundos
        setInterval(() => {
            if (testRunning) {
                tidalCamera.updateMetrics();
            }
        }, 5000);
        
    </script>
</body>
</html>
