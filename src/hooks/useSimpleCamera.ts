import { useState, useCallback, useRef, useEffect } from 'react';

// Clave para localStorage
const CAMERA_STORAGE_KEY = 'houndtrade_camera_state';

// Funci√≥n para cargar estado desde localStorage
const loadCameraState = () => {
  try {
    const saved = localStorage.getItem(CAMERA_STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      console.log('üì∑ [SimpleCamera] Estado cargado desde localStorage:', parsed);
      return parsed;
    }
  } catch (error) {
    console.warn('üì∑ [SimpleCamera] Error cargando estado desde localStorage:', error);
  }
  return null;
};

// Funci√≥n para guardar estado en localStorage
const saveCameraState = (state: any) => {
  try {
    localStorage.setItem(CAMERA_STORAGE_KEY, JSON.stringify(state));
    console.log('üì∑ [SimpleCamera] Estado guardado en localStorage:', state);
  } catch (error) {
    console.warn('üì∑ [SimpleCamera] Error guardando estado en localStorage:', error);
  }
};

export interface SimpleCameraState {
  // Configuraci√≥n de la c√°mara
  visibleCandles: number;
  startIndex: number;
  endIndex: number;
  
  // Estado del usuario
  isUserInteracting: boolean;
  lastUserAction: number | null;
  
  // Estado de Chart.js (para web)
  chartJsState: {
    min: number | null;
    max: number | null;
    centerX: number | null;
    zoomLevel: number | null;
  };
  
  // Configuraci√≥n b√°sica
  defaultVisibleCandles: number;
}

export interface SimpleCameraControls {
  state: SimpleCameraState;
  
  // M√©todos principales
  onUserStartInteraction: () => void;
  onUserEndInteraction: () => void;
  onUserZoom: (min: number, max: number, centerX?: number, zoomLevel?: number) => void;
  onUserPan: (min: number, max: number, centerX?: number) => void;
  
  // Control de c√°mara
  resetToLatest: () => void;
  lockCurrentPosition: () => void;
  isLocked: () => boolean;
  
  // Para integraci√≥n con Chart.js
  getRecommendedViewport: (totalCandles: number, candleData: any[]) => {
    startIndex: number;
    endIndex: number;
    min: number | null;
    max: number | null;
  };
}

interface UseSimpleCameraProps {
  defaultVisibleCandles?: number;
  autoResetTimeMs?: number;
  onStateChange?: (state: SimpleCameraState) => void;
}

export const useSimpleCamera = ({
  defaultVisibleCandles = 100,
  autoResetTimeMs = 0, // Deshabilitado - sin auto-reset
  onStateChange
}: UseSimpleCameraProps = {}): SimpleCameraControls => {
  
  // Cargar estado inicial desde localStorage
  const savedState = loadCameraState();
  
  // Estado principal - inicializar con datos guardados si existen
  const [visibleCandles, setVisibleCandles] = useState(defaultVisibleCandles);
  const [startIndex, setStartIndex] = useState(0);
  const [endIndex, setEndIndex] = useState(defaultVisibleCandles);
  const [isUserInteracting, setIsUserInteracting] = useState(savedState?.isUserInteracting || false);
  const [lastUserAction, setLastUserAction] = useState<number | null>(savedState?.lastUserAction || null);
  const [chartJsState, setChartJsState] = useState({
    min: savedState?.chartJsState?.min || null,
    max: savedState?.chartJsState?.max || null,
    centerX: savedState?.chartJsState?.centerX || null,
    zoomLevel: savedState?.chartJsState?.zoomLevel || null,
  });
  
  // Referencias para timers
  const autoResetTimer = useRef<NodeJS.Timeout | null>(null);
  
  // Estado combinado
  const state: SimpleCameraState = {
    visibleCandles,
    startIndex,
    endIndex,
    isUserInteracting,
    lastUserAction,
    chartJsState,
    defaultVisibleCandles,
  };
  
  // Notificar cambios de estado y guardar en localStorage
  useEffect(() => {
    onStateChange?.(state);
    
    // Guardar en localStorage solo si el usuario ha interactuado
    if (lastUserAction !== null) {
      saveCameraState({
        isUserInteracting,
        lastUserAction,
        chartJsState,
        visibleCandles,
        startIndex,
        endIndex
      });
    }
  }, [isUserInteracting, lastUserAction, visibleCandles, startIndex, endIndex, chartJsState.min, chartJsState.max]);
  
  // Auto-reset timer (DESHABILITADO - c√°mara debe ser independiente del streaming)
  const startAutoResetTimer = useCallback(() => {
    console.log('üì∑ [SimpleCamera] Auto-reset DESHABILITADO - c√°mara permanece donde usuario la dej√≥');
    
    // NO ejecutar auto-reset autom√°tico
    // La c√°mara debe quedarse independiente del live streaming
    /*
    if (autoResetTimer.current) {
      clearTimeout(autoResetTimer.current);
    }
    
    autoResetTimer.current = setTimeout(() => {
      console.log('üì∑ [SimpleCamera] Auto-reset despu√©s de inactividad');
      setIsUserInteracting(false);
      setLastUserAction(null);
      setChartJsState({
        min: null,
        max: null,
        centerX: null,
        zoomLevel: null,
      });
      setVisibleCandles(defaultVisibleCandles);
    }, autoResetTimeMs);
    */
  }, []);
  
  // Cuando el usuario INICIA interacci√≥n
  const onUserStartInteraction = useCallback(() => {
    console.log('üì∑ [SimpleCamera] Usuario INICIA interacci√≥n - BLOQUEANDO auto-seguimiento');
    setIsUserInteracting(true);
    setLastUserAction(Date.now());
    
    // Cancelar auto-reset mientras interact√∫a
    if (autoResetTimer.current) {
      clearTimeout(autoResetTimer.current);
    }
  }, []);
  
  // Cuando el usuario TERMINA interacci√≥n
  const onUserEndInteraction = useCallback(() => {
    console.log('üì∑ [SimpleCamera] Usuario TERMINA interacci√≥n - MANTENIENDO posici√≥n fija (sin auto-reset)');
    setLastUserAction(Date.now());
    
    // NO iniciar timer de auto-reset - la c√°mara debe quedarse donde el usuario la dej√≥
    // startAutoResetTimer(); // ‚Üê COMENTADO: esto causaba que se resetee autom√°ticamente
    
    // La c√°mara se queda exactamente donde el usuario la dej√≥
    console.log('üì∑ [SimpleCamera] C√°mara fijada en posici√≥n del usuario permanentemente');
  }, []);
  
  // Cuando el usuario hace zoom
  const onUserZoom = useCallback((min: number, max: number, centerX?: number, zoomLevel?: number) => {
    console.log('üì∑ [SimpleCamera] Usuario hizo ZOOM - guardando estado:', { min, max, centerX, zoomLevel });
    
    setChartJsState({
      min,
      max,
      centerX: centerX || null,
      zoomLevel: zoomLevel || null,
    });
    
    setLastUserAction(Date.now());
  }, []);
  
  // Cuando el usuario hace pan
  const onUserPan = useCallback((min: number, max: number, centerX?: number) => {
    console.log('üì∑ [SimpleCamera] Usuario hizo PAN - guardando estado:', { min, max, centerX });
    
    setChartJsState(prev => ({
      ...prev,
      min,
      max,
      centerX: centerX || null,
    }));
    
    setLastUserAction(Date.now());
  }, []);
  
  // Reset manual a las √∫ltimas velas
  const resetToLatest = useCallback(() => {
    console.log('üì∑ [SimpleCamera] RESET MANUAL a las √∫ltimas', defaultVisibleCandles, 'velas');
    
    // Limpiar timer
    if (autoResetTimer.current) {
      clearTimeout(autoResetTimer.current);
    }
    
    // Reset completo
    setIsUserInteracting(false);
    setLastUserAction(null);
    setChartJsState({
      min: null,
      max: null,
      centerX: null,
      zoomLevel: null,
    });
    setVisibleCandles(defaultVisibleCandles);
    setStartIndex(0);
    setEndIndex(defaultVisibleCandles);
    
    // Limpiar localStorage
    try {
      localStorage.removeItem(CAMERA_STORAGE_KEY);
      console.log('üì∑ [SimpleCamera] Estado limpiado de localStorage');
    } catch (error) {
      console.warn('üì∑ [SimpleCamera] Error limpiando localStorage:', error);
    }
  }, [defaultVisibleCandles]);
  
  // Bloquear posici√≥n actual
  const lockCurrentPosition = useCallback(() => {
    console.log('üì∑ [SimpleCamera] BLOQUEANDO posici√≥n actual');
    setIsUserInteracting(true);
    setLastUserAction(Date.now());
  }, []);
  
  // Verificar si est√° bloqueado
  const isLocked = useCallback(() => {
    // Bloqueado si el usuario ha interactuado alguna vez Y tiene configuraci√≥n guardada
    return lastUserAction !== null && (
      chartJsState.min !== null || 
      chartJsState.max !== null || 
      isUserInteracting
    );
  }, [lastUserAction, chartJsState.min, chartJsState.max, isUserInteracting]);
  
  // Obtener viewport recomendado
  const getRecommendedViewport = useCallback((totalCandles: number, candleData: any[]) => {
    // SIEMPRE priorizar configuraci√≥n del usuario si existe
    if (lastUserAction !== null && chartJsState.min !== null && chartJsState.max !== null) {
      console.log('üì∑ [SimpleCamera] Usando configuraci√≥n del usuario (prioritaria):', chartJsState);
      return {
        startIndex: 0,
        endIndex: totalCandles,
        min: chartJsState.min,
        max: chartJsState.max,
      };
    }
    
    // Solo configurar vista inicial autom√°tica si NO hay configuraci√≥n del usuario
    if (lastUserAction === null) {
      const targetVisible = Math.min(visibleCandles, totalCandles);
      const calculatedStartIndex = Math.max(0, totalCandles - targetVisible);
      const calculatedEndIndex = totalCandles;
      
      let min: number | null = null;
      let max: number | null = null;
      
      if (candleData && candleData.length > 0) {
        const startCandle = candleData[calculatedStartIndex];
        const endCandle = candleData[calculatedEndIndex - 1];
        
        if (startCandle && endCandle) {
          min = startCandle.x || startCandle.time;
          max = endCandle.x || endCandle.time;
        }
      }
      
      console.log('üì∑ [SimpleCamera] Configuraci√≥n inicial autom√°tica (solo sin usuario):', { min, max, targetVisible });
      
      return {
        startIndex: calculatedStartIndex,
        endIndex: calculatedEndIndex,
        min,
        max,
      };
    }
    
    // Si el usuario interactu√≥ pero se perdi√≥ la configuraci√≥n, NO cambiar nada
    console.log('üì∑ [SimpleCamera] Usuario interactu√≥ pero configuraci√≥n perdida - manteniendo vista actual');
    return {
      startIndex: 0,
      endIndex: totalCandles,
      min: null,
      max: null,
    };
  }, [lastUserAction, chartJsState, visibleCandles]);
  
  // Limpiar timer al desmontar
  useEffect(() => {
    return () => {
      if (autoResetTimer.current) {
        clearTimeout(autoResetTimer.current);
      }
    };
  }, []);
  
  return {
    state,
    onUserStartInteraction,
    onUserEndInteraction,
    onUserZoom,
    onUserPan,
    resetToLatest,
    lockCurrentPosition,
    isLocked,
    getRecommendedViewport,
  };
};
